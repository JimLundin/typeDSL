[project]
name = "typeDSL"
version = "0.1.0"
description = "A type-safe node system for building ASTs and DSLs in Python 3.12+"
readme = "README.md"
license = { text = "Apache-2.0" }
authors = [
    { name = "Jim Lundin", email = "JimLundin@users.noreply.github.com" },
]
requires-python = ">=3.12"
dependencies = []
keywords = [
    "ast",
    "dsl",
    "nodes",
    "type-safe",
    "serialization",
    "schema",
    "parser",
    "compiler",
]
classifiers = [
    "Development Status :: 4 - Beta",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: Apache Software License",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: 3.13",
    "Topic :: Software Development :: Libraries :: Python Modules",
    "Topic :: Software Development :: Compilers",
    "Topic :: Software Development :: Code Generators",
    "Typing :: Typed",
]

[project.urls]
Homepage = "https://github.com/JimLundin/typeDSL"
Repository = "https://github.com/JimLundin/typeDSL"
Issues = "https://github.com/JimLundin/typeDSL/issues"
Documentation = "https://github.com/JimLundin/typeDSL#readme"

[build-system]
requires = ["uv_build>=0.8.17,<0.9.0"]
build-backend = "uv_build"

[dependency-groups]
dev = ["mypy>=1.19.0", "pyright>=1.1.407", "pytest>=9.0.1", "ruff>=0.14.7"]

[tool.mypy]
strict = true

[tool.pyright]
typeCheckingMode = "strict"

[[tool.pyright.executionEnvironments]]
root = "src/typedsl"
reportUnknownArgumentType = "warning"
reportUnknownVariableType = "warning"
reportUnnecessaryIsInstance = "warning"  # Defensive checks for invalid inputs are fine
reportPrivateUsage = "warning"  # Internal cross-module access is intentional

[tool.ruff]
unsafe-fixes = true

[tool.ruff.lint]
select = ["ALL"]
fixable = ["ALL"]
ignore = [
    "D203",  # incompatible with D211
    "D213",  # incompatible with D212
]

[tool.ruff.lint.per-file-ignores]
# Tests: allow asserts, magic values, code-like comments, naive datetimes, missing docstrings in mocks
"tests/**" = ["S101", "PLR2004", "ERA001", "DTZ001", "D102", "A004"]
# Examples: demo code, allow missing docstrings, asserts, magic values, implicit namespace
"examples/**" = ["D100", "D101", "D102", "D103", "D107", "S101", "PLR2004", "INP001", "ANN401"]
# Type manipulation code legitimately requires Any for runtime type introspection
"src/typedsl/schema.py" = [
    "ANN401",   # Any required for extract_type(py_type: Any)
    "C901",     # extract_type is a type dispatch function, complexity is inherent
    "PLR0911",  # multiple returns needed for type dispatch
    "PLR0912",  # multiple branches needed for type dispatch
]
"src/typedsl/nodes.py" = ["ANN401"]  # __init_subclass__ accepts arbitrary **kwargs
"src/typedsl/types.py" = ["ANN401"]  # substitute_type_params handles arbitrary type expressions
"src/typedsl/codecs.py" = [
    "ANN401",   # serialization handles arbitrary values
    "C901",     # type dispatch functions are inherently complex
    "PLR0911",  # multiple returns needed for type dispatch
    "PLR0912",  # multiple branches needed for type dispatch
    "SLF001",   # intentionally accesses TypeDef._register_external
]
"src/typedsl/formats/*.py" = [
    "ANN401",   # serialization handles arbitrary values
    "TRY004",   # ValueError is more appropriate for invalid data format
]
# Type checker: pattern matching functions require complexity
"src/typedsl/typechecker/*.py" = [
    "A001",     # TypeError shadows builtin intentionally
    "A004",     # TypeError import shadows builtin intentionally
    "C901",     # pattern matching functions are inherently complex
    "PLR0911",  # multiple returns needed for pattern matching
    "PLR0912",  # multiple branches needed for pattern matching
    "D105",     # __str__ docstring not needed for simple methods
    "D107",     # __init__ docstring not needed for simple methods
    "TRY300",   # return in try block is fine for simple error handling
]
